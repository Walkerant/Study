前面我们已经学习了JavaScript的事件循环机制，了解了一段代码是如何被JavaScript引擎执行的，这是粒度最粗的执行单位。接下来，我们开始学习粒度较小的单位：函数的执行机制，以及和函数执行过程相关的所有问题。

# 闭包closure

在计算机领域，闭包closure有三个完全不同的意义：
1. 在编译原理中，它是处理语法产生式的一个步骤；
2. 在计算几何中，它表示包裹平面点集的凸多边形；
3. 在编程语言领域，它表示一种特殊的函数。

上个世界60年代，主流编程语言是基于lambda演算的函数式编程语言，所以最初的闭包定义，使用了大量的函数式术语。一个不太精确的定义是“带有一系列信息的λ表达式”，λ表达式就是函数。

>我们可以这样简单理解一下，闭包其实只是一个绑定了执行环境的函数，这个函数并不是印在书本里的一条简单的表达式，闭包与普通函数的区别是，它携带了执行的环境，就像人在外星中需要自带吸氧的装备一样，这个函数也带有在程序中生存的环境。

普通的函数就是一系列表达式的集合，只要给定参数，就会得到确定的结果。而闭包还可以携带大量上下文信息，这函数的执行变得捉摸不定，有时候很难理解，但这也是闭包之所以强大的地方。

最初的闭包定义中，包含两部分内容：
- 环境部分
    - 环境
    - 标识符列表
- 表达式部分

这个定义对应到JavaScript标准中，则是：
- 环境部分
    - 环境：函数的词法环境（执行上下文的一部分）
    - 标识符列表：函数中用到的未声明变量
- 表达式部分：函数体

至此，我们可以认为，JavaScript中的函数完全符合闭包的定义。它的环境部分是函数词法环境部分组成，它的标识符列表是函数中用到的未声明变量，它的表达式部分就是函数体。

## 变量作用域
每个编程语言中都有作用域这个概念，JavaScript也不例外。

JavaScript中的作用域无非两种：全局变量和局部变量，函数内部可以直接读取全局变量，但是函数外部无法获取内部的局部变量。这里有一个地方需要注意，函数内部声明变量的时候，一定要使用`var`命令。如果不用的话，你实际上声明了一个全局变量！
```js
    function f1(){
    　　　n=999;
    }

    f1();

    alert(n); // 999
```

如果非要在函数外部获取函数内的局部变量，通过在函数里面定义一个函数，将要返回的局部变量返回，再返回新定义的函数也能实现。
```js
　　function f1(){

　　　　var n=999;

　　　　function f2(){
　　　　　　alert(n);
　　　　}

　　　　return f2;

　　}

　　var result=f1();

　　result(); // 999
```

## 闭包作用
闭包的作用主要有两个，一个是前面说的读取函数内部的局部变量，另一个是让某些变量始终保存在内存中。

```js
　　function f1(){

　　　　var n=999;

　　　　nAdd=function(){n+=1}   //没有使用var关键字，所以定义了一个全局变量

　　　　function f2(){
　　　　　　alert(n);
　　　　}

　　　　return f2;

　　}

　　var result=f1();

　　result(); // 999

　　nAdd();

　　result(); // 1000
```

在上面的代码中，`f1`运行之后，就会将局部变量`n`保存在内存中，同时在全局作用域中加入`nAdd`，运行`nAdd`保存在内存中的局部变量`n`就会被加1，从而得到1000。

# 执行上下文

执行一段JavaScript代码，不光需要全局变量和局部变量，还需要处理`this`、`with`等特殊语法，这些信息让JavaScript代码的执行变得更加复杂。JavaScript标准把一段代码，执行所需要的一切信息定义为“执行上下文”。

这一部分内容经历了多个版本的演变，下面来梳理一下。

### ES3
执行上下文在ES3中，包含三个部分。

- scope：作用域，也常常被叫做作用域链。
- variable object：变量对象，用于存储变量的对象。
- this value：this值。

### ES5
在ES5中，改进了命名方式，把执行上下文最初的三个部分改为下面这个样子。

- lexical environment：词法环境，当获取变量时使用。
- variable environment：变量环境，当声明变量时使用。
- this value：this值。

### ES2018
在ES2018中，执行上下文又变成了这个样子，this值被归入lexical environment，但是增加了不少内容。

- lexical environment：词法环境，当获取变量或者this值时使用。
- variable environment：变量环境，当声明变量时使用
- code evaluation state：用于恢复代码执行位置。
- Function：执行的任务是函数时使用，表示正在被执行的函数。
- ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码。
- Realm：使用的基础库和内置对象实例。
- Generator：仅生成器上下文有这个属性，表示当前生成器。

如果从实现语言的角度去分析这些内容，肯定不容易理解。从实际代码出发，去一步一步分析代码执行过程中，需要哪些信息，将是一个更好的选择。如下这些代码：

```js
    var b = {}
    let c = 1
    this.a = 2;
```

要想正确执行它，我们需要知道以下信息：

1. `var` 把 `b` 声明到哪里；
2. `b` 表示哪个变量；
3. `b` 的原型是哪个对象；
4. `let` 把 `c` 声明到哪里；
5. `this` 指向哪个对象。

## `var`变量声明

`var`是用于声明变量的关键字，它最大的缺陷就是会穿透当前作用域，让变量上升到上层作用域中。例如下面的代码：
```js
    if (true) {
        var test = true;
    }

    alert(test); // true

    for (var i = 0; i < 10; i++) {
        console.log(i)
    }

    alert(i);   // 10
```

所以，`var`会穿透`if`、`for`等代码块，进入更上层的作用域。但是，如果在function内定义的变量，则不会影响函数外部。
```js
    function sayHi() {
        if (true) {
            var phrase = "Hello";
        }

        alert(phrase); // works
    }

    sayHi();
    alert(phrase); // Error: phrase is not defined
```

针对`var`的这种问题，在没有`let`的时代，有个可以修复方案：立即执行的函数表达式（IIFE），通过创建一个函数，并立即执行，就像上面的例子一样，可以完美解决变量提升的缺陷。
```js
    (function() {
        var message = "Hello";
        alert(message); // Hello
    })();
```

## `let`

`let`是从ES6开始引入的新的变量声明方式，比起`var`的诸多弊病，`let`做了非常明确的梳理和规定。

为了实现`let`，JavaScript在运行时引入了块级作用域。以下语句中，都会产生let使用的作用域：
- `for`
- `if`
- `switch`
- `try/catch/finally`

另外，如果用`let`重新变量，会报错。如下所示：
```js
let user;
let user; // Uncaught SyntaxError: Identifier 'user' has already been declared
```

为了减少不必要的麻烦，建议使用多使用let，甚至全用let声明变量。